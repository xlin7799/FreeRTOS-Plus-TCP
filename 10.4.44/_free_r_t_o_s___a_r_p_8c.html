<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_ARP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V2.3.4</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___a_r_p_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_ARP.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the Address Resolution Protocol for the FreeRTOS+TCP network stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Timers.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22f53fd4d5218d841f6176b29603a955"><td class="memItemLeft" align="right" valign="top"><a id="a22f53fd4d5218d841f6176b29603a955" name="a22f53fd4d5218d841f6176b29603a955"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST</b>&#160;&#160;&#160;( 3 )</td></tr>
<tr class="memdesc:a22f53fd4d5218d841f6176b29603a955"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the age of an entry in the ARP table reaches this value (it counts down to zero, so this is an old entry) an ARP request will be sent to see if the entry is still valid and can therefore be refreshed. <br /></td></tr>
<tr class="separator:a22f53fd4d5218d841f6176b29603a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="memItemLeft" align="right" valign="top"><a id="a7b4eb297ab0d35cfe95b1879495a3d7f" name="a7b4eb297ab0d35cfe95b1879495a3d7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpGRATUITOUS_ARP_PERIOD</b>&#160;&#160;&#160;( pdMS_TO_TICKS( 20000U ) )</td></tr>
<tr class="memdesc:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time between gratuitous ARPs. <br /></td></tr>
<tr class="separator:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="memItemLeft" align="right" valign="top"><a id="ad51f57e1abecd75f22c0d8eca8d87a4d" name="ad51f57e1abecd75f22c0d8eca8d87a4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpIP_CLASH_RESET_TIMEOUT_MS</b>&#160;&#160;&#160;10000U</td></tr>
<tr class="memdesc:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When there is another device which has the same IP address as the IP address of this device, a defensive ARP request should be sent out. However, according to RFC 5227 section 1.1, there must be a minimum interval of 10 seconds between consecutive defensive ARP packets. <br /></td></tr>
<tr class="separator:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6df3b8e26c0a0849fa35199c82f714"><td class="memItemLeft" align="right" valign="top"><a id="a6a6df3b8e26c0a0849fa35199c82f714" name="a6a6df3b8e26c0a0849fa35199c82f714"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpIP_CLASH_MAX_RETRIES</b>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a6a6df3b8e26c0a0849fa35199c82f714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of defensive ARPs to be sent for an ARP clash per arpIP_CLASH_RESET_TIMEOUT_MS period. The retries are limited to one as outlined by RFC 5227 section 2.4 part b. <br /></td></tr>
<tr class="separator:a6a6df3b8e26c0a0849fa35199c82f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a78b76b83a58bdb609db07f2949b39dcb"><td class="memItemLeft" align="right" valign="top">static eARPLookupResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a78b76b83a58bdb609db07f2949b39dcb">prvCacheLookup</a> (uint32_t ulAddressToLookup, MACAddress_t *const pxMACAddress)</td></tr>
<tr class="memdesc:a78b76b83a58bdb609db07f2949b39dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an IP address in the ARP cache.  <a href="_free_r_t_o_s___a_r_p_8c.html#a78b76b83a58bdb609db07f2949b39dcb">More...</a><br /></td></tr>
<tr class="separator:a78b76b83a58bdb609db07f2949b39dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e04baa9cd61b32738c01b39c7af408"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a88e04baa9cd61b32738c01b39c7af408">vProcessARPPacketReply</a> (const ARPPacket_t *pxARPFrame, uint32_t ulSenderProtocolAddress)</td></tr>
<tr class="memdesc:a88e04baa9cd61b32738c01b39c7af408"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device has sent an ARP reply, process it.  <a href="_free_r_t_o_s___a_r_p_8c.html#a88e04baa9cd61b32738c01b39c7af408">More...</a><br /></td></tr>
<tr class="separator:a88e04baa9cd61b32738c01b39c7af408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06d3a8a2d409547e12b4825ebc885b5"><td class="memItemLeft" align="right" valign="top">eFrameProcessingResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#aa06d3a8a2d409547e12b4825ebc885b5">eARPProcessPacket</a> (ARPPacket_t *const pxARPFrame)</td></tr>
<tr class="memdesc:aa06d3a8a2d409547e12b4825ebc885b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the ARP packets.  <a href="_free_r_t_o_s___a_r_p_8c.html#aa06d3a8a2d409547e12b4825ebc885b5">More...</a><br /></td></tr>
<tr class="separator:aa06d3a8a2d409547e12b4825ebc885b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc995bea37f826daf44d59f5bcd0fc7"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#afdc995bea37f826daf44d59f5bcd0fc7">xIsIPInARPCache</a> (uint32_t ulAddressToLookup)</td></tr>
<tr class="memdesc:afdc995bea37f826daf44d59f5bcd0fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an IP address is in the ARP cache.  <a href="_free_r_t_o_s___a_r_p_8c.html#afdc995bea37f826daf44d59f5bcd0fc7">More...</a><br /></td></tr>
<tr class="separator:afdc995bea37f826daf44d59f5bcd0fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a978aa66440ed327d71f7d4b2daa63"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#ae2a978aa66440ed327d71f7d4b2daa63">xCheckRequiresARPResolution</a> (const NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ae2a978aa66440ed327d71f7d4b2daa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a packet needs ARP resolution if it is on local subnet. If required send an ARP request.  <a href="_free_r_t_o_s___a_r_p_8c.html#ae2a978aa66440ed327d71f7d4b2daa63">More...</a><br /></td></tr>
<tr class="separator:ae2a978aa66440ed327d71f7d4b2daa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9740bba27acb79ac417f9b187630e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#aa9740bba27acb79ac417f9b187630e3b">vARPRefreshCacheEntry</a> (const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:aa9740bba27acb79ac417f9b187630e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update the ARP cache entry MAC-address to IP-address mapping.  <a href="_free_r_t_o_s___a_r_p_8c.html#aa9740bba27acb79ac417f9b187630e3b">More...</a><br /></td></tr>
<tr class="separator:aa9740bba27acb79ac417f9b187630e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee3377f9c286506135c17be1962d8d6"><td class="memItemLeft" align="right" valign="top">eARPLookupResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a1ee3377f9c286506135c17be1962d8d6">eARPGetCacheEntry</a> (uint32_t *pulIPAddress, MACAddress_t *const pxMACAddress)</td></tr>
<tr class="memdesc:a1ee3377f9c286506135c17be1962d8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for ulIPAddress in the ARP cache.  <a href="_free_r_t_o_s___a_r_p_8c.html#a1ee3377f9c286506135c17be1962d8d6">More...</a><br /></td></tr>
<tr class="separator:a1ee3377f9c286506135c17be1962d8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="memItemLeft" align="right" valign="top"><a id="a3d3934dd27e4d024ab7a14ed0c80b3cc" name="a3d3934dd27e4d024ab7a14ed0c80b3cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vARPAgeCache</b> (void)</td></tr>
<tr class="memdesc:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this function will update (or 'Age') the ARP cache entries. The function will also try to prevent a removal of entry by sending an ARP query. It will also check whether we are waiting on an ARP reply - if we are, then an ARP request will be re-sent. In case an ARP entry has 'Aged' to 0, it will be removed from the ARP cache. <br /></td></tr>
<tr class="separator:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96d87a3e4505229094bf3d81330c2f4"><td class="memItemLeft" align="right" valign="top"><a id="aa96d87a3e4505229094bf3d81330c2f4" name="aa96d87a3e4505229094bf3d81330c2f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vARPSendGratuitous</b> (void)</td></tr>
<tr class="memdesc:aa96d87a3e4505229094bf3d81330c2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Gratuitous ARP packet to allow this node to announce the IP-MAC mapping to the entire network. <br /></td></tr>
<tr class="separator:aa96d87a3e4505229094bf3d81330c2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a87ebc2f32c8cda6cdc24a265df2388c0">FreeRTOS_OutputARPRequest</a> (uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and send an ARP request packet.  <a href="_free_r_t_o_s___a_r_p_8c.html#a87ebc2f32c8cda6cdc24a265df2388c0">More...</a><br /></td></tr>
<tr class="separator:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7afccbd744a2ee150ddf209c5582bf"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a1b7afccbd744a2ee150ddf209c5582bf">xARPWaitResolution</a> (uint32_t ulIPAddress, TickType_t uxTicksToWait)</td></tr>
<tr class="memdesc:a1b7afccbd744a2ee150ddf209c5582bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for address resolution: look-up the IP-address in the ARP-cache, and if needed send an ARP request, and wait for a reply. This function is useful when called before <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a>.  <a href="_free_r_t_o_s___a_r_p_8c.html#a1b7afccbd744a2ee150ddf209c5582bf">More...</a><br /></td></tr>
<tr class="separator:a1b7afccbd744a2ee150ddf209c5582bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27861e019fb0f3c1d5579f6806f75b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a27861e019fb0f3c1d5579f6806f75b4c">vARPGenerateRequestPacket</a> (NetworkBufferDescriptor_t *const pxNetworkBuffer)</td></tr>
<tr class="memdesc:a27861e019fb0f3c1d5579f6806f75b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an ARP request packet by copying various constant details to the buffer.  <a href="_free_r_t_o_s___a_r_p_8c.html#a27861e019fb0f3c1d5579f6806f75b4c">More...</a><br /></td></tr>
<tr class="separator:a27861e019fb0f3c1d5579f6806f75b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad41b60042629fc57086d4990fc6347"><td class="memItemLeft" align="right" valign="top"><a id="a7ad41b60042629fc57086d4990fc6347" name="a7ad41b60042629fc57086d4990fc6347"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreeRTOS_ClearARP</b> (void)</td></tr>
<tr class="memdesc:a7ad41b60042629fc57086d4990fc6347"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this function will clear the ARP cache. <br /></td></tr>
<tr class="separator:a7ad41b60042629fc57086d4990fc6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0927214ffe1d8b142d6e49fc26430339"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a0927214ffe1d8b142d6e49fc26430339">xCheckLoopback</a> (NetworkBufferDescriptor_t *const pxDescriptor, BaseType_t bReleaseAfterSend)</td></tr>
<tr class="memdesc:a0927214ffe1d8b142d6e49fc26430339"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will check if the target IP-address belongs to this device. If so, the packet will be passed to the IP-stack, who will answer it. The function is to be called within the function xNetworkInterfaceOutput().  <a href="_free_r_t_o_s___a_r_p_8c.html#a0927214ffe1d8b142d6e49fc26430339">More...</a><br /></td></tr>
<tr class="separator:a0927214ffe1d8b142d6e49fc26430339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afdc43c741d35db756e9a4ca5cd064bf1"><td class="memItemLeft" align="right" valign="top"><a id="afdc43c741d35db756e9a4ca5cd064bf1" name="afdc43c741d35db756e9a4ca5cd064bf1"></a>
_static ARPCacheRow_t&#160;</td><td class="memItemRight" valign="bottom"><b>xARPCache</b> [ipconfigARP_CACHE_ENTRIES]</td></tr>
<tr class="memdesc:afdc43c741d35db756e9a4ca5cd064bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ARP cache. <br /></td></tr>
<tr class="separator:afdc43c741d35db756e9a4ca5cd064bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3721b546b6d8021730dbc1d49c263"><td class="memItemLeft" align="right" valign="top"><a id="aa9c3721b546b6d8021730dbc1d49c263" name="aa9c3721b546b6d8021730dbc1d49c263"></a>
static TickType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xLastGratuitousARPTime</b> = 0U</td></tr>
<tr class="memdesc:aa9c3721b546b6d8021730dbc1d49c263"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time at which the last gratuitous ARP was sent. Gratuitous ARPs are used to ensure ARP tables are up to date and to detect IP address conflicts. <br /></td></tr>
<tr class="separator:aa9c3721b546b6d8021730dbc1d49c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements the Address Resolution Protocol for the FreeRTOS+TCP network stack. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a78b76b83a58bdb609db07f2949b39dcb" name="a78b76b83a58bdb609db07f2949b39dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b76b83a58bdb609db07f2949b39dcb">&#9670;&nbsp;</a></span>prvCacheLookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static eARPLookupResult_t prvCacheLookup </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddressToLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *const&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup an IP address in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddressToLookup</td><td>The 32-bit representation of an IP address to lookup. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxMACAddress</td><td>A pointer to MACAddress_t variable where, if there is an ARP cache hit, the MAC address corresponding to the IP address will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When the IP-address is found: eARPCacheHit, when not found: eARPCacheMiss, and when waiting for a ARP reply: eCantSendPacket. </dd></dl>

</div>
</div>
<a id="a88e04baa9cd61b32738c01b39c7af408" name="a88e04baa9cd61b32738c01b39c7af408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e04baa9cd61b32738c01b39c7af408">&#9670;&nbsp;</a></span>vProcessARPPacketReply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vProcessARPPacketReply </td>
          <td>(</td>
          <td class="paramtype">const ARPPacket_t *&#160;</td>
          <td class="paramname"><em>pxARPFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulSenderProtocolAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A device has sent an ARP reply, process it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxARPFrame</td><td>The ARP packet received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulSenderProtocolAddress</td><td>The IPv4 address involved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa06d3a8a2d409547e12b4825ebc885b5" name="aa06d3a8a2d409547e12b4825ebc885b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06d3a8a2d409547e12b4825ebc885b5">&#9670;&nbsp;</a></span>eARPProcessPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eFrameProcessingResult_t eARPProcessPacket </td>
          <td>(</td>
          <td class="paramtype">ARPPacket_t *const&#160;</td>
          <td class="paramname"><em>pxARPFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the ARP packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxARPFrame</td><td>The ARP Frame (the ARP packet).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum which says whether to return the frame or to release it. </dd></dl>

</div>
</div>
<a id="afdc995bea37f826daf44d59f5bcd0fc7" name="afdc995bea37f826daf44d59f5bcd0fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc995bea37f826daf44d59f5bcd0fc7">&#9670;&nbsp;</a></span>xIsIPInARPCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIsIPInARPCache </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddressToLookup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an IP address is in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddressToLookup</td><td>The 32-bit representation of an IP address to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When the IP-address is found: pdTRUE, else pdFALSE. </dd></dl>

</div>
</div>
<a id="ae2a978aa66440ed327d71f7d4b2daa63" name="ae2a978aa66440ed327d71f7d4b2daa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a978aa66440ed327d71f7d4b2daa63">&#9670;&nbsp;</a></span>xCheckRequiresARPResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xCheckRequiresARPResolution </td>
          <td>(</td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a packet needs ARP resolution if it is on local subnet. If required send an ARP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer with the packet to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the packet needs ARP resolution, pdFALSE otherwise. </dd></dl>

</div>
</div>
<a id="aa9740bba27acb79ac417f9b187630e3b" name="aa9740bba27acb79ac417f9b187630e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9740bba27acb79ac417f9b187630e3b">&#9670;&nbsp;</a></span>vARPRefreshCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vARPRefreshCacheEntry </td>
          <td>(</td>
          <td class="paramtype">const MACAddress_t *&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add/update the ARP cache entry MAC-address to IP-address mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxMACAddress</td><td>Pointer to the MAC address whose mapping is being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>32-bit representation of the IP-address whose mapping is being updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ee3377f9c286506135c17be1962d8d6" name="a1ee3377f9c286506135c17be1962d8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee3377f9c286506135c17be1962d8d6">&#9670;&nbsp;</a></span>eARPGetCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eARPLookupResult_t eARPGetCacheEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *const&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for ulIPAddress in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pulIPAddress</td><td>Pointer to the IP-address to be queried to the ARP cache. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxMACAddress</td><td>Pointer to a MACAddress_t variable where the MAC address will be stored, if found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the IP address exists, copy the associated MAC address into pxMACAddress, refresh the ARP cache entry's age, and return eARPCacheHit. If the IP address does not exist in the ARP cache return eARPCacheMiss. If the packet cannot be sent for any reason (maybe DHCP is still in process, or the addressing needs a gateway but there isn't a gateway defined) then return eCantSendPacket. </dd></dl>

</div>
</div>
<a id="a87ebc2f32c8cda6cdc24a265df2388c0" name="a87ebc2f32c8cda6cdc24a265df2388c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ebc2f32c8cda6cdc24a265df2388c0">&#9670;&nbsp;</a></span>FreeRTOS_OutputARPRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_OutputARPRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and send an ARP request packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>A 32-bit representation of the IP-address whose physical (MAC) address is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7afccbd744a2ee150ddf209c5582bf" name="a1b7afccbd744a2ee150ddf209c5582bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7afccbd744a2ee150ddf209c5582bf">&#9670;&nbsp;</a></span>xARPWaitResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xARPWaitResolution </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTicksToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for address resolution: look-up the IP-address in the ARP-cache, and if needed send an ARP request, and wait for a reply. This function is useful when called before <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>The IP-address to look-up. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTicksToWait</td><td>The maximum number of clock ticks to wait for a reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero when successful. </dd></dl>

</div>
</div>
<a id="a27861e019fb0f3c1d5579f6806f75b4c" name="a27861e019fb0f3c1d5579f6806f75b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27861e019fb0f3c1d5579f6806f75b4c">&#9670;&nbsp;</a></span>vARPGenerateRequestPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vARPGenerateRequestPacket </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an ARP request packet by copying various constant details to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxNetworkBuffer</td><td>Pointer to the buffer which has to be filled with the ARP request packet details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0927214ffe1d8b142d6e49fc26430339" name="a0927214ffe1d8b142d6e49fc26430339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0927214ffe1d8b142d6e49fc26430339">&#9670;&nbsp;</a></span>xCheckLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xCheckLoopback </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *const&#160;</td>
          <td class="paramname"><em>pxDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>bReleaseAfterSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will check if the target IP-address belongs to this device. If so, the packet will be passed to the IP-stack, who will answer it. The function is to be called within the function xNetworkInterfaceOutput(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDescriptor</td><td>The network buffer which is to be checked for loop-back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bReleaseAfterSend</td><td>pdTRUE: Driver is allowed to transfer ownership of descriptor. pdFALSE: Driver is not allowed to take ownership of descriptor, make a copy of it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE/pdFALSE: There is/isn't a loopback address in the packet. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html">FreeRTOS_ARP.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
