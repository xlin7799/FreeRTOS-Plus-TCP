<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_Sockets.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V2.3.4</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___sockets_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_Sockets.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the Sockets API based on Berkeley sockets for the FreeRTOS+TCP network stack. Sockets are used by the application processes to interact with the IP-task which in turn interacts with the hardware.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8fc4e3506e42e9eef4b51ffd91e665b3"><td class="memItemLeft" align="right" valign="top"><a id="a8fc4e3506e42e9eef4b51ffd91e665b3" name="a8fc4e3506e42e9eef4b51ffd91e665b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketSET_SOCKET_PORT</b>(pxSocket,  usPort)&#160;&#160;&#160;listSET_LIST_ITEM_VALUE( ( &amp;( ( pxSocket )-&gt;xBoundSocketListItem ) ), ( usPort ) )</td></tr>
<tr class="memdesc:a8fc4e3506e42e9eef4b51ffd91e665b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the port number for the socket in the xBoundSocketListItem. <br /></td></tr>
<tr class="separator:a8fc4e3506e42e9eef4b51ffd91e665b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a0b0023a907a0cff7dc53d226f80cd"><td class="memItemLeft" align="right" valign="top"><a id="ab3a0b0023a907a0cff7dc53d226f80cd" name="ab3a0b0023a907a0cff7dc53d226f80cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketGET_SOCKET_PORT</b>(pxSocket)&#160;&#160;&#160;listGET_LIST_ITEM_VALUE( ( &amp;( ( pxSocket )-&gt;xBoundSocketListItem ) ) )</td></tr>
<tr class="memdesc:ab3a0b0023a907a0cff7dc53d226f80cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the port number for the socket in the xBoundSocketListItem. <br /></td></tr>
<tr class="separator:ab3a0b0023a907a0cff7dc53d226f80cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01dee7309f496afde943fed947729c"><td class="memItemLeft" align="right" valign="top"><a id="a2e01dee7309f496afde943fed947729c" name="a2e01dee7309f496afde943fed947729c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketSOCKET_IS_BOUND</b>(pxSocket)&#160;&#160;&#160;( listLIST_ITEM_CONTAINER( &amp;( pxSocket )-&gt;xBoundSocketListItem ) != NULL )</td></tr>
<tr class="memdesc:a2e01dee7309f496afde943fed947729c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a socket it bound which means it is either included in xBoundUDPSocketsList or xBoundTCPSocketsList. <br /></td></tr>
<tr class="separator:a2e01dee7309f496afde943fed947729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350b6e0f49c270cb5c13c6aeeae116af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a350b6e0f49c270cb5c13c6aeeae116af">socketAUTO_PORT_ALLOCATION_START_NUMBER</a>&#160;&#160;&#160;( ( uint16_t ) 0x0400 )</td></tr>
<tr class="memdesc:a350b6e0f49c270cb5c13c6aeeae116af"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a> is called on a socket that is not bound to a port number then, depending on the FreeRTOSIPConfig.h settings, it might be that a port number is automatically generated for the socket. Automatically generated port numbers will be between socketAUTO_PORT_ALLOCATION_START_NUMBER and 0xffff.  <a href="_free_r_t_o_s___sockets_8c.html#a350b6e0f49c270cb5c13c6aeeae116af">More...</a><br /></td></tr>
<tr class="separator:a350b6e0f49c270cb5c13c6aeeae116af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3319ecf6f85a2b64a8d48396e0279e24"><td class="memItemLeft" align="right" valign="top"><a id="a3319ecf6f85a2b64a8d48396e0279e24" name="a3319ecf6f85a2b64a8d48396e0279e24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketAUTO_PORT_ALLOCATION_MAX_NUMBER</b>&#160;&#160;&#160;( ( uint16_t ) 0xffff )</td></tr>
<tr class="memdesc:a3319ecf6f85a2b64a8d48396e0279e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of port number which can be auto assigned. <br /></td></tr>
<tr class="separator:a3319ecf6f85a2b64a8d48396e0279e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc265c349a43891cb7ab972fd58630e9"><td class="memItemLeft" align="right" valign="top"><a id="afc265c349a43891cb7ab972fd58630e9" name="afc265c349a43891cb7ab972fd58630e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketMAX_IP_ADDRESS_OCTETS</b>&#160;&#160;&#160;4U</td></tr>
<tr class="memdesc:afc265c349a43891cb7ab972fd58630e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of octets that make up an IP address. <br /></td></tr>
<tr class="separator:afc265c349a43891cb7ab972fd58630e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8714f024edfbb0a683d31d2ee7e60"><td class="memItemLeft" align="right" valign="top"><a id="a42f8714f024edfbb0a683d31d2ee7e60" name="a42f8714f024edfbb0a683d31d2ee7e60"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketDONT_BLOCK</b>&#160;&#160;&#160;( ( TickType_t ) 0 )</td></tr>
<tr class="memdesc:a42f8714f024edfbb0a683d31d2ee7e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block time of 0 simply means "don't block". <br /></td></tr>
<tr class="separator:a42f8714f024edfbb0a683d31d2ee7e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1630538f6d0701a36f878b67bbff8f"><td class="memItemLeft" align="right" valign="top"><a id="aef1630538f6d0701a36f878b67bbff8f" name="aef1630538f6d0701a36f878b67bbff8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipTCP_TIMER_PERIOD_MS</b>&#160;&#160;&#160;( 1000U )</td></tr>
<tr class="memdesc:aef1630538f6d0701a36f878b67bbff8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TCP timer period in milliseconds. <br /></td></tr>
<tr class="separator:aef1630538f6d0701a36f878b67bbff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68795ded8df36253a9ae4a48f728f863"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a68795ded8df36253a9ae4a48f728f863">sock20_PERCENT</a>&#160;&#160;&#160;20U</td></tr>
<tr class="separator:a68795ded8df36253a9ae4a48f728f863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63599b39bbf9eea1e37fcbb06035027d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a63599b39bbf9eea1e37fcbb06035027d">sock80_PERCENT</a>&#160;&#160;&#160;80U</td></tr>
<tr class="separator:a63599b39bbf9eea1e37fcbb06035027d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b2a67aa4db57cbda7a7150eb4f58f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a67b2a67aa4db57cbda7a7150eb4f58f6">sock100_PERCENT</a>&#160;&#160;&#160;100U</td></tr>
<tr class="separator:a67b2a67aa4db57cbda7a7150eb4f58f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e9c7b59621e91931c386d250690133"><td class="memItemLeft" align="right" valign="top"><a id="aa6e9c7b59621e91931c386d250690133" name="aa6e9c7b59621e91931c386d250690133"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>socketINVALID_HEX_CHAR</b>&#160;&#160;&#160;0xffU</td></tr>
<tr class="memdesc:aa6e9c7b59621e91931c386d250690133"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <a class="el" href="_free_r_t_o_s___sockets_8c.html#abc24f2109dbf606cb72a63cf8ba8086a" title="Convert an ASCII character to its corresponding hexadecimal value. Accepted characters are 0-9,...">ucASCIIToHex()</a> can not convert a character, the value 255 will be returned. <br /></td></tr>
<tr class="separator:aa6e9c7b59621e91931c386d250690133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93067b1b641f4859cd5501786573802"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ad93067b1b641f4859cd5501786573802">sockDIGIT_COUNT</a>&#160;&#160;&#160;( 3U )</td></tr>
<tr class="separator:ad93067b1b641f4859cd5501786573802"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83a99d42729cdba57e78dd6c3c9e66e1"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a83a99d42729cdba57e78dd6c3c9e66e1">prvGetPrivatePortNumber</a> (BaseType_t xProtocol)</td></tr>
<tr class="memdesc:a83a99d42729cdba57e78dd6c3c9e66e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an available port number per <a href="https://tools.ietf.org/html/rfc6056">https://tools.ietf.org/html/rfc6056</a>.  <a href="_free_r_t_o_s___sockets_8c.html#a83a99d42729cdba57e78dd6c3c9e66e1">More...</a><br /></td></tr>
<tr class="separator:a83a99d42729cdba57e78dd6c3c9e66e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0788754fab0379fd522b0ff849692fc4"><td class="memItemLeft" align="right" valign="top">static const ListItem_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a0788754fab0379fd522b0ff849692fc4">pxListFindListItemWithValue</a> (const List_t *pxList, TickType_t xWantedItemValue)</td></tr>
<tr class="memdesc:a0788754fab0379fd522b0ff849692fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a list item associated with the wanted-item.  <a href="_free_r_t_o_s___sockets_8c.html#a0788754fab0379fd522b0ff849692fc4">More...</a><br /></td></tr>
<tr class="separator:a0788754fab0379fd522b0ff849692fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4328ec58511a541031cc6a60da027ab4"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a4328ec58511a541031cc6a60da027ab4">prvValidSocket</a> (const FreeRTOS_Socket_t *pxSocket, BaseType_t xProtocol, BaseType_t xIsBound)</td></tr>
<tr class="memdesc:a4328ec58511a541031cc6a60da027ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is valid or not.  <a href="_free_r_t_o_s___sockets_8c.html#a4328ec58511a541031cc6a60da027ab4">More...</a><br /></td></tr>
<tr class="separator:a4328ec58511a541031cc6a60da027ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43126375c017bf52614bff3f1702d1b1"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a43126375c017bf52614bff3f1702d1b1">prvSockopt_so_buffer</a> (FreeRTOS_Socket_t *pxSocket, int32_t lOptionName, const void *pvOptionValue)</td></tr>
<tr class="memdesc:a43126375c017bf52614bff3f1702d1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of receive/send buffer after some preliminary checks.  <a href="_free_r_t_o_s___sockets_8c.html#a43126375c017bf52614bff3f1702d1b1">More...</a><br /></td></tr>
<tr class="separator:a43126375c017bf52614bff3f1702d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed71e4108c462911d2fa3229eec6df6"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a4ed71e4108c462911d2fa3229eec6df6">prvDetermineSocketSize</a> (BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol, size_t *pxSocketSize)</td></tr>
<tr class="memdesc:a4ed71e4108c462911d2fa3229eec6df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the socket size for the given protocol.  <a href="_free_r_t_o_s___sockets_8c.html#a4ed71e4108c462911d2fa3229eec6df6">More...</a><br /></td></tr>
<tr class="separator:a4ed71e4108c462911d2fa3229eec6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc24f2109dbf606cb72a63cf8ba8086a"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#abc24f2109dbf606cb72a63cf8ba8086a">ucASCIIToHex</a> (char cChar)</td></tr>
<tr class="memdesc:abc24f2109dbf606cb72a63cf8ba8086a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an ASCII character to its corresponding hexadecimal value. Accepted characters are 0-9, a-f, and A-F.  <a href="_free_r_t_o_s___sockets_8c.html#abc24f2109dbf606cb72a63cf8ba8086a">More...</a><br /></td></tr>
<tr class="separator:abc24f2109dbf606cb72a63cf8ba8086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe49f69aeaa10ff6d5d7d2cc82c71d"><td class="memItemLeft" align="right" valign="top">static StreamBuffer_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a6fbe49f69aeaa10ff6d5d7d2cc82c71d">prvTCPCreateStream</a> (FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream)</td></tr>
<tr class="memdesc:a6fbe49f69aeaa10ff6d5d7d2cc82c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the stream buffer for the given socket.  <a href="_free_r_t_o_s___sockets_8c.html#a6fbe49f69aeaa10ff6d5d7d2cc82c71d">More...</a><br /></td></tr>
<tr class="separator:a6fbe49f69aeaa10ff6d5d7d2cc82c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad719999c8bcbddf392affdeb6be2f554"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ad719999c8bcbddf392affdeb6be2f554">prvTCPSendCheck</a> (FreeRTOS_Socket_t *pxSocket, size_t uxDataLength)</td></tr>
<tr class="memdesc:ad719999c8bcbddf392affdeb6be2f554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a>: some checks which will be done before sending a TCP packed.  <a href="_free_r_t_o_s___sockets_8c.html#ad719999c8bcbddf392affdeb6be2f554">More...</a><br /></td></tr>
<tr class="separator:ad719999c8bcbddf392affdeb6be2f554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91064db1bf7a4b1f49922c8f9927c701"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a91064db1bf7a4b1f49922c8f9927c701">prvTCPSetSocketCount</a> (FreeRTOS_Socket_t const *pxSocketToDelete)</td></tr>
<tr class="memdesc:a91064db1bf7a4b1f49922c8f9927c701"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a child socket gets closed, make sure to update the child-count of the parent. When a listening parent socket is closed, make sure to close also all orphaned child-sockets.  <a href="_free_r_t_o_s___sockets_8c.html#a91064db1bf7a4b1f49922c8f9927c701">More...</a><br /></td></tr>
<tr class="separator:a91064db1bf7a4b1f49922c8f9927c701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d910cb9c6b4f63d7f8a75cd1ed7fa62"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a5d910cb9c6b4f63d7f8a75cd1ed7fa62">prvTCPConnectStart</a> (FreeRTOS_Socket_t *pxSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr const *pxAddress)</td></tr>
<tr class="memdesc:a5d910cb9c6b4f63d7f8a75cd1ed7fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="_free_r_t_o_s___sockets_8c.html#a6231fb49e0a656c63d0ef82db2446587" title="Connect to a remote port.">FreeRTOS_connect()</a>: make some checks and if allowed, send a message to the IP-task to start connecting to a remote socket.  <a href="_free_r_t_o_s___sockets_8c.html#a5d910cb9c6b4f63d7f8a75cd1ed7fa62">More...</a><br /></td></tr>
<tr class="separator:a5d910cb9c6b4f63d7f8a75cd1ed7fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5f1c37d0260304e2acb616ca18247"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ae8a5f1c37d0260304e2acb616ca18247">bMayConnect</a> (FreeRTOS_Socket_t const *pxSocket)</td></tr>
<tr class="memdesc:ae8a5f1c37d0260304e2acb616ca18247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes any sense to wait for a connect event.  <a href="_free_r_t_o_s___sockets_8c.html#ae8a5f1c37d0260304e2acb616ca18247">More...</a><br /></td></tr>
<tr class="separator:ae8a5f1c37d0260304e2acb616ca18247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69915c323634b32c5534bd1a17b79673"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a69915c323634b32c5534bd1a17b79673">prvFindSelectedSocket</a> (SocketSelect_t *pxSocketSet)</td></tr>
<tr class="memdesc:a69915c323634b32c5534bd1a17b79673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the IP-task to have it check all sockets belonging to 'pxSocketSet'.  <a href="_free_r_t_o_s___sockets_8c.html#a69915c323634b32c5534bd1a17b79673">More...</a><br /></td></tr>
<tr class="separator:a69915c323634b32c5534bd1a17b79673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4143378ec838cd340efd7f95b30444a5"><td class="memItemLeft" align="right" valign="top"><a id="a4143378ec838cd340efd7f95b30444a5" name="a4143378ec838cd340efd7f95b30444a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vNetworkSocketsInit</b> (void)</td></tr>
<tr class="memdesc:a4143378ec838cd340efd7f95b30444a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the bound TCP/UDP socket lists. <br /></td></tr>
<tr class="separator:a4143378ec838cd340efd7f95b30444a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0707f288bef6f9a6cafd3dc3c4cfab99"><td class="memItemLeft" align="right" valign="top">Socket_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a0707f288bef6f9a6cafd3dc3c4cfab99">FreeRTOS_socket</a> (BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol)</td></tr>
<tr class="memdesc:a0707f288bef6f9a6cafd3dc3c4cfab99"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate and initialise a socket.  <a href="_free_r_t_o_s___sockets_8c.html#a0707f288bef6f9a6cafd3dc3c4cfab99">More...</a><br /></td></tr>
<tr class="separator:a0707f288bef6f9a6cafd3dc3c4cfab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffb7662be38da18db6ec8e87da4735e"><td class="memItemLeft" align="right" valign="top">SocketSet_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a6ffb7662be38da18db6ec8e87da4735e">FreeRTOS_CreateSocketSet</a> (void)</td></tr>
<tr class="memdesc:a6ffb7662be38da18db6ec8e87da4735e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket set.  <a href="_free_r_t_o_s___sockets_8c.html#a6ffb7662be38da18db6ec8e87da4735e">More...</a><br /></td></tr>
<tr class="separator:a6ffb7662be38da18db6ec8e87da4735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427e342cb8d9c513d117ba772f427cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a427e342cb8d9c513d117ba772f427cca">FreeRTOS_DeleteSocketSet</a> (SocketSet_t xSocketSet)</td></tr>
<tr class="memdesc:a427e342cb8d9c513d117ba772f427cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a given socket set.  <a href="_free_r_t_o_s___sockets_8c.html#a427e342cb8d9c513d117ba772f427cca">More...</a><br /></td></tr>
<tr class="separator:a427e342cb8d9c513d117ba772f427cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf33877d948d53b4b189ddc41718ccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#accf33877d948d53b4b189ddc41718ccd">FreeRTOS_FD_SET</a> (Socket_t xSocket, SocketSet_t xSocketSet, EventBits_t xBitsToSet)</td></tr>
<tr class="memdesc:accf33877d948d53b4b189ddc41718ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a socket to a set.  <a href="_free_r_t_o_s___sockets_8c.html#accf33877d948d53b4b189ddc41718ccd">More...</a><br /></td></tr>
<tr class="separator:accf33877d948d53b4b189ddc41718ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd213d4d45a6dbc0e900f52f2b4541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a7ecd213d4d45a6dbc0e900f52f2b4541">FreeRTOS_FD_CLR</a> (Socket_t xSocket, SocketSet_t xSocketSet, EventBits_t xBitsToClear)</td></tr>
<tr class="memdesc:a7ecd213d4d45a6dbc0e900f52f2b4541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear select bits for a socket. If the mask becomes 0, remove the socket from the set.  <a href="_free_r_t_o_s___sockets_8c.html#a7ecd213d4d45a6dbc0e900f52f2b4541">More...</a><br /></td></tr>
<tr class="separator:a7ecd213d4d45a6dbc0e900f52f2b4541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05335fc45cca27dd28f122bb0f68bc"><td class="memItemLeft" align="right" valign="top">EventBits_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a8f05335fc45cca27dd28f122bb0f68bc">FreeRTOS_FD_ISSET</a> (const ConstSocket_t xSocket, const ConstSocketSet_t xSocketSet)</td></tr>
<tr class="memdesc:a8f05335fc45cca27dd28f122bb0f68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a socket belongs to a socket-set and if so, which event bit(s) are set.  <a href="_free_r_t_o_s___sockets_8c.html#a8f05335fc45cca27dd28f122bb0f68bc">More...</a><br /></td></tr>
<tr class="separator:a8f05335fc45cca27dd28f122bb0f68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659a570c1f1b5a11c17d816cb5541291"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291">FreeRTOS_select</a> (SocketSet_t xSocketSet, TickType_t xBlockTimeTicks)</td></tr>
<tr class="memdesc:a659a570c1f1b5a11c17d816cb5541291"><td class="mdescLeft">&#160;</td><td class="mdescRight">The select() statement: wait for an event to occur on any of the sockets included in a socket set.  <a href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291">More...</a><br /></td></tr>
<tr class="separator:a659a570c1f1b5a11c17d816cb5541291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63957c5dde05f3a130cf7190aa935e25"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a63957c5dde05f3a130cf7190aa935e25">FreeRTOS_recvfrom</a> (const ConstSocket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFlags, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxSourceAddress, const socklen_t *pxSourceAddressLength)</td></tr>
<tr class="memdesc:a63957c5dde05f3a130cf7190aa935e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from a bound socket. In this library, the function can only be used with connection-less sockets (UDP). For TCP sockets, please use <a class="el" href="_free_r_t_o_s___sockets_8c.html#a44ab7ba5fddce925519c7ccc7b887033" title="Read incoming data from a TCP socket. Only after the last byte has been read, a close error might be ...">FreeRTOS_recv()</a>.  <a href="_free_r_t_o_s___sockets_8c.html#a63957c5dde05f3a130cf7190aa935e25">More...</a><br /></td></tr>
<tr class="separator:a63957c5dde05f3a130cf7190aa935e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c30950fb7db5b68e0c4dcbbf838049b"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a3c30950fb7db5b68e0c4dcbbf838049b">prvMakeSureSocketIsBound</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a3c30950fb7db5b68e0c4dcbbf838049b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a socket is a valid UDP socket. In case it is not yet bound, bind it to port 0 ( random port ).  <a href="_free_r_t_o_s___sockets_8c.html#a3c30950fb7db5b68e0c4dcbbf838049b">More...</a><br /></td></tr>
<tr class="separator:a3c30950fb7db5b68e0c4dcbbf838049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493cacf34d993b8b87c41242d7fc6d1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1">FreeRTOS_sendto</a> (Socket_t xSocket, const void *pvBuffer, size_t uxTotalDataLength, BaseType_t xFlags, const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxDestinationAddress, socklen_t xDestinationAddressLength)</td></tr>
<tr class="memdesc:a1493cacf34d993b8b87c41242d7fc6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a socket. The socket must have already been created by a successful call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a0707f288bef6f9a6cafd3dc3c4cfab99" title="allocate and initialise a socket.">FreeRTOS_socket()</a>. It works for UDP-sockets only.  <a href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1">More...</a><br /></td></tr>
<tr class="separator:a1493cacf34d993b8b87c41242d7fc6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe933805d4f44b09b3b04a13ed28e72"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a6fe933805d4f44b09b3b04a13ed28e72">FreeRTOS_bind</a> (Socket_t xSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr const *pxAddress, socklen_t xAddressLength)</td></tr>
<tr class="memdesc:a6fe933805d4f44b09b3b04a13ed28e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">binds a socket to a local port number. If port 0 is provided, a system provided port number will be assigned. This function can be used for both UDP and TCP sockets. The actual binding will be performed by the IP-task to avoid mutual access to the bound-socket-lists (xBoundUDPSocketsList or xBoundTCPSocketsList).  <a href="_free_r_t_o_s___sockets_8c.html#a6fe933805d4f44b09b3b04a13ed28e72">More...</a><br /></td></tr>
<tr class="separator:a6fe933805d4f44b09b3b04a13ed28e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add35977107add8357366416d55c64e69"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#add35977107add8357366416d55c64e69">vSocketBind</a> (FreeRTOS_Socket_t *pxSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxBindAddress, size_t uxAddressLength, BaseType_t xInternal)</td></tr>
<tr class="memdesc:add35977107add8357366416d55c64e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal version of bind() that should not be called directly. 'xInternal' is used for TCP sockets only: it allows to have several (connected) child sockets bound to the same server port.  <a href="_free_r_t_o_s___sockets_8c.html#add35977107add8357366416d55c64e69">More...</a><br /></td></tr>
<tr class="separator:add35977107add8357366416d55c64e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefb0186bf6e06816a6acd12432dae9b"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#abefb0186bf6e06816a6acd12432dae9b">FreeRTOS_closesocket</a> (Socket_t xSocket)</td></tr>
<tr class="memdesc:abefb0186bf6e06816a6acd12432dae9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a socket and free the allocated space. In case of a TCP socket: the connection will not be closed automatically. Subsequent messages for the closed socket will be responded to with a RST. The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message.  <a href="_free_r_t_o_s___sockets_8c.html#abefb0186bf6e06816a6acd12432dae9b">More...</a><br /></td></tr>
<tr class="separator:abefb0186bf6e06816a6acd12432dae9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef498fc07f15ceb8828c60decabfbb8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#afef498fc07f15ceb8828c60decabfbb8">vSocketClose</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:afef498fc07f15ceb8828c60decabfbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the internal version of <a class="el" href="_free_r_t_o_s___sockets_8c.html#abefb0186bf6e06816a6acd12432dae9b" title="Close a socket and free the allocated space. In case of a TCP socket: the connection will not be clos...">FreeRTOS_closesocket()</a>. It will be called by the IPtask only to avoid problems with synchronicity.  <a href="_free_r_t_o_s___sockets_8c.html#afef498fc07f15ceb8828c60decabfbb8">More...</a><br /></td></tr>
<tr class="separator:afef498fc07f15ceb8828c60decabfbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faeae52e5489bc7b5ee8ab9392630d5"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a7faeae52e5489bc7b5ee8ab9392630d5">FreeRTOS_setsockopt</a> (Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t uxOptionLength)</td></tr>
<tr class="memdesc:a7faeae52e5489bc7b5ee8ab9392630d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the socket options for the given socket.  <a href="_free_r_t_o_s___sockets_8c.html#a7faeae52e5489bc7b5ee8ab9392630d5">More...</a><br /></td></tr>
<tr class="separator:a7faeae52e5489bc7b5ee8ab9392630d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bf0f1817a52cf72307092b6e5cdcbf"><td class="memItemLeft" align="right" valign="top">FreeRTOS_Socket_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ac3bf0f1817a52cf72307092b6e5cdcbf">pxUDPSocketLookup</a> (UBaseType_t uxLocalPort)</td></tr>
<tr class="memdesc:ac3bf0f1817a52cf72307092b6e5cdcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the UDP socket corresponding to the port number.  <a href="_free_r_t_o_s___sockets_8c.html#ac3bf0f1817a52cf72307092b6e5cdcbf">More...</a><br /></td></tr>
<tr class="separator:ac3bf0f1817a52cf72307092b6e5cdcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa2ddd54f04e8314a9b357527c53f56"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a9fa2ddd54f04e8314a9b357527c53f56">FreeRTOS_inet_ntoa</a> (uint32_t ulIPAddress, char *pcBuffer)</td></tr>
<tr class="memdesc:a9fa2ddd54f04e8314a9b357527c53f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the 32-bit representation of the IP-address to the dotted decimal notation after some checks. A safe alternative is <a class="el" href="_free_r_t_o_s___sockets_8c.html#a2a1d585f75b8fc47161cab0113b38174" title="Convert the 32-bit representation of the IP-address to the dotted decimal format.">FreeRTOS_inet_ntop4()</a>.  <a href="_free_r_t_o_s___sockets_8c.html#a9fa2ddd54f04e8314a9b357527c53f56">More...</a><br /></td></tr>
<tr class="separator:a9fa2ddd54f04e8314a9b357527c53f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae572a3caf62d61b5aaeb462914516"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a47ae572a3caf62d61b5aaeb462914516">FreeRTOS_inet_pton</a> (BaseType_t xAddressFamily, const char *pcSource, void *pvDestination)</td></tr>
<tr class="memdesc:a47ae572a3caf62d61b5aaeb462914516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the dotted decimal format of the IP-address to the 32-bit representation.  <a href="_free_r_t_o_s___sockets_8c.html#a47ae572a3caf62d61b5aaeb462914516">More...</a><br /></td></tr>
<tr class="separator:a47ae572a3caf62d61b5aaeb462914516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f93b995b905805c8dc17bbd97ce04"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#aac0f93b995b905805c8dc17bbd97ce04">FreeRTOS_inet_ntop</a> (BaseType_t xAddressFamily, const void *pvSource, char *pcDestination, socklen_t uxSize)</td></tr>
<tr class="memdesc:aac0f93b995b905805c8dc17bbd97ce04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the 32-bit representation of the IP-address to the dotted decimal format based on the Address Family. (Only FREERTOS_AF_INET is allowed).  <a href="_free_r_t_o_s___sockets_8c.html#aac0f93b995b905805c8dc17bbd97ce04">More...</a><br /></td></tr>
<tr class="separator:aac0f93b995b905805c8dc17bbd97ce04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1d585f75b8fc47161cab0113b38174"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a2a1d585f75b8fc47161cab0113b38174">FreeRTOS_inet_ntop4</a> (const void *pvSource, char *pcDestination, socklen_t uxSize)</td></tr>
<tr class="memdesc:a2a1d585f75b8fc47161cab0113b38174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the 32-bit representation of the IP-address to the dotted decimal format.  <a href="_free_r_t_o_s___sockets_8c.html#a2a1d585f75b8fc47161cab0113b38174">More...</a><br /></td></tr>
<tr class="separator:a2a1d585f75b8fc47161cab0113b38174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ca5deaf06141eb65d09ba28c6b8ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a078ca5deaf06141eb65d09ba28c6b8ac">FreeRTOS_EUI48_ntop</a> (const uint8_t *pucSource, char *pcTarget, char cTen, char cSeparator)</td></tr>
<tr class="memdesc:a078ca5deaf06141eb65d09ba28c6b8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a 48-bit MAC address to a human readable string.  <a href="_free_r_t_o_s___sockets_8c.html#a078ca5deaf06141eb65d09ba28c6b8ac">More...</a><br /></td></tr>
<tr class="separator:a078ca5deaf06141eb65d09ba28c6b8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4741626233348eae3ac3d7d9c7de73fb"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a4741626233348eae3ac3d7d9c7de73fb">FreeRTOS_EUI48_pton</a> (const char *pcSource, uint8_t *pucTarget)</td></tr>
<tr class="memdesc:a4741626233348eae3ac3d7d9c7de73fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a human readable string, representing an 48-bit MAC address, into a 6-byte address. Valid inputs are e.g. "62:48:5:83:A0:b2" and "0-12-34-fe-dc-ba".  <a href="_free_r_t_o_s___sockets_8c.html#a4741626233348eae3ac3d7d9c7de73fb">More...</a><br /></td></tr>
<tr class="separator:a4741626233348eae3ac3d7d9c7de73fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3306e04e9b856682503e39f856ec7ff"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ae3306e04e9b856682503e39f856ec7ff">FreeRTOS_inet_pton4</a> (const char *pcSource, void *pvDestination)</td></tr>
<tr class="memdesc:ae3306e04e9b856682503e39f856ec7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the character string pcSource into a network address structure, then copies the network address structure to pvDestination. pvDestination is written in network byte order.  <a href="_free_r_t_o_s___sockets_8c.html#ae3306e04e9b856682503e39f856ec7ff">More...</a><br /></td></tr>
<tr class="separator:ae3306e04e9b856682503e39f856ec7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f785c94c2b8d0c80cf615a898c70b8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a17f785c94c2b8d0c80cf615a898c70b8">FreeRTOS_inet_addr</a> (const char *pcIPAddress)</td></tr>
<tr class="memdesc:a17f785c94c2b8d0c80cf615a898c70b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the IP address from "w.x.y.z" (dotted decimal) format to the 32-bit format.  <a href="_free_r_t_o_s___sockets_8c.html#a17f785c94c2b8d0c80cf615a898c70b8">More...</a><br /></td></tr>
<tr class="separator:a17f785c94c2b8d0c80cf615a898c70b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd261a29fa206a8664ab5171ad9570"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a5cfd261a29fa206a8664ab5171ad9570">FreeRTOS_GetLocalAddress</a> (ConstSocket_t xSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress)</td></tr>
<tr class="memdesc:a5cfd261a29fa206a8664ab5171ad9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the local address and IP port of the given socket.  <a href="_free_r_t_o_s___sockets_8c.html#a5cfd261a29fa206a8664ab5171ad9570">More...</a><br /></td></tr>
<tr class="separator:a5cfd261a29fa206a8664ab5171ad9570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0387edebc3e7bcf7fcf038a01a098213"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a0387edebc3e7bcf7fcf038a01a098213">vSocketWakeUpUser</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a0387edebc3e7bcf7fcf038a01a098213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up the user of the given socket through event-groups.  <a href="_free_r_t_o_s___sockets_8c.html#a0387edebc3e7bcf7fcf038a01a098213">More...</a><br /></td></tr>
<tr class="separator:a0387edebc3e7bcf7fcf038a01a098213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231fb49e0a656c63d0ef82db2446587"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a6231fb49e0a656c63d0ef82db2446587">FreeRTOS_connect</a> (Socket_t xClientSocket, const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress, socklen_t xAddressLength)</td></tr>
<tr class="memdesc:a6231fb49e0a656c63d0ef82db2446587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote port.  <a href="_free_r_t_o_s___sockets_8c.html#a6231fb49e0a656c63d0ef82db2446587">More...</a><br /></td></tr>
<tr class="separator:a6231fb49e0a656c63d0ef82db2446587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0aabc4d95b9a61e531429839f50852"><td class="memItemLeft" align="right" valign="top">Socket_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a1b0aabc4d95b9a61e531429839f50852">FreeRTOS_accept</a> (Socket_t xServerSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress, socklen_t *pxAddressLength)</td></tr>
<tr class="memdesc:a1b0aabc4d95b9a61e531429839f50852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a connection on an listening socket.  <a href="_free_r_t_o_s___sockets_8c.html#a1b0aabc4d95b9a61e531429839f50852">More...</a><br /></td></tr>
<tr class="separator:a1b0aabc4d95b9a61e531429839f50852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ab7ba5fddce925519c7ccc7b887033"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a44ab7ba5fddce925519c7ccc7b887033">FreeRTOS_recv</a> (Socket_t xSocket, void *pvBuffer, size_t uxBufferLength, BaseType_t xFlags)</td></tr>
<tr class="memdesc:a44ab7ba5fddce925519c7ccc7b887033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read incoming data from a TCP socket. Only after the last byte has been read, a close error might be returned.  <a href="_free_r_t_o_s___sockets_8c.html#a44ab7ba5fddce925519c7ccc7b887033">More...</a><br /></td></tr>
<tr class="separator:a44ab7ba5fddce925519c7ccc7b887033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0d5b9bbaa6c1a30a8fb5675fb151f"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a68d0d5b9bbaa6c1a30a8fb5675fb151f">FreeRTOS_get_tx_head</a> (ConstSocket_t xSocket, BaseType_t *pxLength)</td></tr>
<tr class="memdesc:a68d0d5b9bbaa6c1a30a8fb5675fb151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a direct pointer to the circular transmit buffer.  <a href="_free_r_t_o_s___sockets_8c.html#a68d0d5b9bbaa6c1a30a8fb5675fb151f">More...</a><br /></td></tr>
<tr class="separator:a68d0d5b9bbaa6c1a30a8fb5675fb151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb04a35d27c55380be674ebd8204351"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351">FreeRTOS_send</a> (Socket_t xSocket, const void *pvBuffer, size_t uxDataLength, BaseType_t xFlags)</td></tr>
<tr class="memdesc:abfb04a35d27c55380be674ebd8204351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data using a TCP socket. It is not necessary to have the socket connected already. Outgoing data will be stored and delivered as soon as the socket gets connected.  <a href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351">More...</a><br /></td></tr>
<tr class="separator:abfb04a35d27c55380be674ebd8204351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1718a2539e0de40d95472ea59859be5c"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a1718a2539e0de40d95472ea59859be5c">FreeRTOS_listen</a> (Socket_t xSocket, BaseType_t xBacklog)</td></tr>
<tr class="memdesc:a1718a2539e0de40d95472ea59859be5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to put a socket in listen mode.  <a href="_free_r_t_o_s___sockets_8c.html#a1718a2539e0de40d95472ea59859be5c">More...</a><br /></td></tr>
<tr class="separator:a1718a2539e0de40d95472ea59859be5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c0198b40cbd5c5e4bb4f173df4fff1"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#af3c0198b40cbd5c5e4bb4f173df4fff1">FreeRTOS_shutdown</a> (Socket_t xSocket, BaseType_t xHow)</td></tr>
<tr class="memdesc:af3c0198b40cbd5c5e4bb4f173df4fff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown - This function will shut down the connection in both directions. However, it will first deliver all data queued for transmission, and also it will first wait to receive any missing packets from the peer.  <a href="_free_r_t_o_s___sockets_8c.html#af3c0198b40cbd5c5e4bb4f173df4fff1">More...</a><br /></td></tr>
<tr class="separator:af3c0198b40cbd5c5e4bb4f173df4fff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3802e1a3603f571bcb185f2afbd48de"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ad3802e1a3603f571bcb185f2afbd48de">xTCPTimerCheck</a> (BaseType_t xWillSleep)</td></tr>
<tr class="memdesc:ad3802e1a3603f571bcb185f2afbd48de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A TCP timer has expired, now check all TCP sockets for:  <a href="_free_r_t_o_s___sockets_8c.html#ad3802e1a3603f571bcb185f2afbd48de">More...</a><br /></td></tr>
<tr class="separator:ad3802e1a3603f571bcb185f2afbd48de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5c6d5f1fce62700029acd28e5857a1"><td class="memItemLeft" align="right" valign="top">FreeRTOS_Socket_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a1b5c6d5f1fce62700029acd28e5857a1">pxTCPSocketLookup</a> (uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort)</td></tr>
<tr class="memdesc:a1b5c6d5f1fce62700029acd28e5857a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">As multiple sockets may be bound to the same local port number looking up a socket is a little more complex: Both a local port, and a remote port and IP address are being used to find a match. For a socket in listening mode, the remote port and IP address are both 0.  <a href="_free_r_t_o_s___sockets_8c.html#a1b5c6d5f1fce62700029acd28e5857a1">More...</a><br /></td></tr>
<tr class="separator:a1b5c6d5f1fce62700029acd28e5857a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ae5cbba5316a7d0b8b5054cb68cdd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structstruct.html">struct</a> xSTREAM_BUFFER *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a289ae5cbba5316a7d0b8b5054cb68cdd">FreeRTOS_get_rx_buf</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:a289ae5cbba5316a7d0b8b5054cb68cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the web server: borrow the circular Rx buffer for inspection. HTML driver wants to see if a sequence of 13/10/13/10 is available.  <a href="_free_r_t_o_s___sockets_8c.html#a289ae5cbba5316a7d0b8b5054cb68cdd">More...</a><br /></td></tr>
<tr class="separator:a289ae5cbba5316a7d0b8b5054cb68cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ce92b8518f62444aad31e0fb1d424"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a712ce92b8518f62444aad31e0fb1d424">lTCPAddRxdata</a> (FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount)</td></tr>
<tr class="memdesc:a712ce92b8518f62444aad31e0fb1d424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to the RxStream. When uxOffset &gt; 0, data has come in out-of-order and will be put in front of the head so it can not be popped by the user.  <a href="_free_r_t_o_s___sockets_8c.html#a712ce92b8518f62444aad31e0fb1d424">More...</a><br /></td></tr>
<tr class="separator:a712ce92b8518f62444aad31e0fb1d424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d7303574cd99128cbdb79e54adc89"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a9e0d7303574cd99128cbdb79e54adc89">FreeRTOS_GetRemoteAddress</a> (ConstSocket_t xSocket, <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress)</td></tr>
<tr class="memdesc:a9e0d7303574cd99128cbdb79e54adc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the remote IP-address and port number.  <a href="_free_r_t_o_s___sockets_8c.html#a9e0d7303574cd99128cbdb79e54adc89">More...</a><br /></td></tr>
<tr class="separator:a9e0d7303574cd99128cbdb79e54adc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d7c4b5b3eeea34905a4f16b6f13965"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a50d7c4b5b3eeea34905a4f16b6f13965">FreeRTOS_maywrite</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:a50d7c4b5b3eeea34905a4f16b6f13965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the number of bytes that may be added to txStream.  <a href="_free_r_t_o_s___sockets_8c.html#a50d7c4b5b3eeea34905a4f16b6f13965">More...</a><br /></td></tr>
<tr class="separator:a50d7c4b5b3eeea34905a4f16b6f13965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49ef118747de118579ce9ba6e2d3d10"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ab49ef118747de118579ce9ba6e2d3d10">FreeRTOS_tx_space</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:ab49ef118747de118579ce9ba6e2d3d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes that can be written in the Tx buffer of the given socket.  <a href="_free_r_t_o_s___sockets_8c.html#ab49ef118747de118579ce9ba6e2d3d10">More...</a><br /></td></tr>
<tr class="separator:ab49ef118747de118579ce9ba6e2d3d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92a73b86b115ac2caeaf6d98d696723"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#af92a73b86b115ac2caeaf6d98d696723">FreeRTOS_tx_size</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:af92a73b86b115ac2caeaf6d98d696723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes stored in the Tx buffer.  <a href="_free_r_t_o_s___sockets_8c.html#af92a73b86b115ac2caeaf6d98d696723">More...</a><br /></td></tr>
<tr class="separator:af92a73b86b115ac2caeaf6d98d696723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dffb3417a60b9c98108408052579ad"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ad8dffb3417a60b9c98108408052579ad">FreeRTOS_issocketconnected</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:ad8dffb3417a60b9c98108408052579ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the socket connected.  <a href="_free_r_t_o_s___sockets_8c.html#ad8dffb3417a60b9c98108408052579ad">More...</a><br /></td></tr>
<tr class="separator:ad8dffb3417a60b9c98108408052579ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a19083f6bdd12aa4e0a8e508454385"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a10a19083f6bdd12aa4e0a8e508454385">FreeRTOS_mss</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:a10a19083f6bdd12aa4e0a8e508454385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual value of Maximum Segment Size ( MSS ) being used.  <a href="_free_r_t_o_s___sockets_8c.html#a10a19083f6bdd12aa4e0a8e508454385">More...</a><br /></td></tr>
<tr class="separator:a10a19083f6bdd12aa4e0a8e508454385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6df495a5df34259dd6ef400992a46f"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a0a6df495a5df34259dd6ef400992a46f">FreeRTOS_connstatus</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:a0a6df495a5df34259dd6ef400992a46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connection status. The values correspond to the members of the enum 'eIPTCPState_t'.  <a href="_free_r_t_o_s___sockets_8c.html#a0a6df495a5df34259dd6ef400992a46f">More...</a><br /></td></tr>
<tr class="separator:a0a6df495a5df34259dd6ef400992a46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6780a9d34f029526febb9b8a26f1b0c5"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a6780a9d34f029526febb9b8a26f1b0c5">FreeRTOS_rx_size</a> (ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:a6780a9d34f029526febb9b8a26f1b0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes which can be read from the RX stream buffer.  <a href="_free_r_t_o_s___sockets_8c.html#a6780a9d34f029526febb9b8a26f1b0c5">More...</a><br /></td></tr>
<tr class="separator:a6780a9d34f029526febb9b8a26f1b0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3b9e3f9a2a974cd8382c8755e603f"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#ac7d3b9e3f9a2a974cd8382c8755e603f">xSocketValid</a> (const ConstSocket_t xSocket)</td></tr>
<tr class="memdesc:ac7d3b9e3f9a2a974cd8382c8755e603f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given socket is valid or not. Validity is defined as the socket not being NULL and not being Invalid.  <a href="_free_r_t_o_s___sockets_8c.html#ac7d3b9e3f9a2a974cd8382c8755e603f">More...</a><br /></td></tr>
<tr class="separator:ac7d3b9e3f9a2a974cd8382c8755e603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a287752bb66a04cb00ab0e427f4808"><td class="memItemLeft" align="right" valign="top"><a id="a48a287752bb66a04cb00ab0e427f4808" name="a48a287752bb66a04cb00ab0e427f4808"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreeRTOS_netstat</b> (void)</td></tr>
<tr class="memdesc:a48a287752bb66a04cb00ab0e427f4808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the net status. The IP-task will print a summary of all sockets and their connections. <br /></td></tr>
<tr class="separator:a48a287752bb66a04cb00ab0e427f4808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e52838681336e8b2dcd41298072c764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___sockets_8c.html#a4e52838681336e8b2dcd41298072c764">vSocketSelect</a> (const SocketSelect_t *pxSocketSet)</td></tr>
<tr class="memdesc:a4e52838681336e8b2dcd41298072c764"><td class="mdescLeft">&#160;</td><td class="mdescRight">This internal non-blocking function will check all sockets that belong to a select set. The events bits of each socket will be updated, and it will check if an ongoing select() call must be interrupted because of an event has occurred.  <a href="_free_r_t_o_s___sockets_8c.html#a4e52838681336e8b2dcd41298072c764">More...</a><br /></td></tr>
<tr class="separator:a4e52838681336e8b2dcd41298072c764"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0bb39b9379d9271063dad16351b7d3ab"><td class="memItemLeft" align="right" valign="top"><a id="a0bb39b9379d9271063dad16351b7d3ab" name="a0bb39b9379d9271063dad16351b7d3ab"></a>
List_t&#160;</td><td class="memItemRight" valign="bottom"><b>xBoundUDPSocketsList</b></td></tr>
<tr class="memdesc:a0bb39b9379d9271063dad16351b7d3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list that contains mappings between sockets and port numbers. Accesses to this list must be protected by critical sections of some kind. <br /></td></tr>
<tr class="separator:a0bb39b9379d9271063dad16351b7d3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02571e6608569169207562135f16785"><td class="memItemLeft" align="right" valign="top"><a id="ae02571e6608569169207562135f16785" name="ae02571e6608569169207562135f16785"></a>
List_t&#160;</td><td class="memItemRight" valign="bottom"><b>xBoundTCPSocketsList</b></td></tr>
<tr class="memdesc:ae02571e6608569169207562135f16785"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list that contains mappings between sockets and port numbers. Accesses to this list must be protected by critical sections of some kind. <br /></td></tr>
<tr class="separator:ae02571e6608569169207562135f16785"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements the Sockets API based on Berkeley sockets for the FreeRTOS+TCP network stack. Sockets are used by the application processes to interact with the IP-task which in turn interacts with the hardware. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a350b6e0f49c270cb5c13c6aeeae116af" name="a350b6e0f49c270cb5c13c6aeeae116af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350b6e0f49c270cb5c13c6aeeae116af">&#9670;&nbsp;</a></span>socketAUTO_PORT_ALLOCATION_START_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define socketAUTO_PORT_ALLOCATION_START_NUMBER&#160;&#160;&#160;( ( uint16_t ) 0x0400 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a> is called on a socket that is not bound to a port number then, depending on the FreeRTOSIPConfig.h settings, it might be that a port number is automatically generated for the socket. Automatically generated port numbers will be between socketAUTO_PORT_ALLOCATION_START_NUMBER and 0xffff. </p>
<dl class="section note"><dt>Note</dt><dd>Per <a href="https://tools.ietf.org/html/rfc6056">https://tools.ietf.org/html/rfc6056</a>, "the dynamic ports consist of
      the range 49152-65535. However, ephemeral port selection algorithms should
      use the whole range 1024-65535" excluding those already in use (inbound or outbound). </dd></dl>

</div>
</div>
<a id="a68795ded8df36253a9ae4a48f728f863" name="a68795ded8df36253a9ae4a48f728f863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68795ded8df36253a9ae4a48f728f863">&#9670;&nbsp;</a></span>sock20_PERCENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sock20_PERCENT&#160;&#160;&#160;20U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >20% of the defined limit. </p>

</div>
</div>
<a id="a63599b39bbf9eea1e37fcbb06035027d" name="a63599b39bbf9eea1e37fcbb06035027d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63599b39bbf9eea1e37fcbb06035027d">&#9670;&nbsp;</a></span>sock80_PERCENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sock80_PERCENT&#160;&#160;&#160;80U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >80% of the defined limit. </p>

</div>
</div>
<a id="a67b2a67aa4db57cbda7a7150eb4f58f6" name="a67b2a67aa4db57cbda7a7150eb4f58f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b2a67aa4db57cbda7a7150eb4f58f6">&#9670;&nbsp;</a></span>sock100_PERCENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sock100_PERCENT&#160;&#160;&#160;100U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >100% of the defined limit. </p>

</div>
</div>
<a id="ad93067b1b641f4859cd5501786573802" name="ad93067b1b641f4859cd5501786573802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93067b1b641f4859cd5501786573802">&#9670;&nbsp;</a></span>sockDIGIT_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sockDIGIT_COUNT&#160;&#160;&#160;( 3U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Each nibble is expressed in at most 3 digits such as "192". </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a83a99d42729cdba57e78dd6c3c9e66e1" name="a83a99d42729cdba57e78dd6c3c9e66e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a99d42729cdba57e78dd6c3c9e66e1">&#9670;&nbsp;</a></span>prvGetPrivatePortNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t prvGetPrivatePortNumber </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xProtocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an available port number per <a href="https://tools.ietf.org/html/rfc6056">https://tools.ietf.org/html/rfc6056</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xProtocol</td><td>FREERTOS_IPPROTO_TCP/FREERTOS_IPPROTO_UDP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an available protocol port is found then that port number is returned. Or else, 0 is returned. </dd></dl>

</div>
</div>
<a id="a0788754fab0379fd522b0ff849692fc4" name="a0788754fab0379fd522b0ff849692fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0788754fab0379fd522b0ff849692fc4">&#9670;&nbsp;</a></span>pxListFindListItemWithValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const ListItem_t * pxListFindListItemWithValue </td>
          <td>(</td>
          <td class="paramtype">const List_t *&#160;</td>
          <td class="paramname"><em>pxList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>xWantedItemValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a list item associated with the wanted-item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxList</td><td>The list through which the search is to be conducted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xWantedItemValue</td><td>The wanted item whose association is to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list item holding the value being searched for. If nothing is found, then a NULL is returned. </dd></dl>

</div>
</div>
<a id="a4328ec58511a541031cc6a60da027ab4" name="a4328ec58511a541031cc6a60da027ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4328ec58511a541031cc6a60da027ab4">&#9670;&nbsp;</a></span>prvValidSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvValidSocket </td>
          <td>(</td>
          <td class="paramtype">const FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xProtocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xIsBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the socket is valid or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket being checked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xProtocol</td><td>The protocol for which the socket was created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xIsBound</td><td>pdTRUE when the socket should be bound, otherwise pdFALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the socket is valid, then pdPASS is returned or else, pdFAIL is returned. </dd></dl>

</div>
</div>
<a id="a43126375c017bf52614bff3f1702d1b1" name="a43126375c017bf52614bff3f1702d1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43126375c017bf52614bff3f1702d1b1">&#9670;&nbsp;</a></span>prvSockopt_so_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvSockopt_so_buffer </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lOptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvOptionValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of receive/send buffer after some preliminary checks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose options are being set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lOptionName</td><td>The option name: either FREERTOS_SO_SNDBUF or FREERTOS_SO_SNDBUF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvOptionValue</td><td>The value of the option being set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If there is no error, then 0 is returned. Or a negative errno value is returned. </dd></dl>

</div>
</div>
<a id="a4ed71e4108c462911d2fa3229eec6df6" name="a4ed71e4108c462911d2fa3229eec6df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed71e4108c462911d2fa3229eec6df6">&#9670;&nbsp;</a></span>prvDetermineSocketSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvDetermineSocketSize </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xProtocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pxSocketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the socket size for the given protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xDomain</td><td>The domain for which the size of socket is being determined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xType</td><td>Is this a datagram socket or a stream socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xProtocol</td><td>The protocol being used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxSocketSize</td><td>Pointer to a variable in which the size shall be returned if all checks pass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS if socket size was determined and put in the parameter pxSocketSize correctly, else pdFAIL. </dd></dl>

</div>
</div>
<a id="abc24f2109dbf606cb72a63cf8ba8086a" name="abc24f2109dbf606cb72a63cf8ba8086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc24f2109dbf606cb72a63cf8ba8086a">&#9670;&nbsp;</a></span>ucASCIIToHex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t ucASCIIToHex </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cChar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an ASCII character to its corresponding hexadecimal value. Accepted characters are 0-9, a-f, and A-F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cChar</td><td>The character to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hexadecimal value, between 0 and 15. When the character is not valid, socketINVALID_HEX_CHAR will be returned. </dd></dl>

</div>
</div>
<a id="a6fbe49f69aeaa10ff6d5d7d2cc82c71d" name="a6fbe49f69aeaa10ff6d5d7d2cc82c71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbe49f69aeaa10ff6d5d7d2cc82c71d">&#9670;&nbsp;</a></span>prvTCPCreateStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StreamBuffer_t * prvTCPCreateStream </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xIsInputStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the stream buffer for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>the socket to create the stream for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xIsInputStream</td><td>Is this input stream? pdTRUE/pdFALSE?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stream buffer. </dd></dl>

</div>
</div>
<a id="ad719999c8bcbddf392affdeb6be2f554" name="ad719999c8bcbddf392affdeb6be2f554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad719999c8bcbddf392affdeb6be2f554">&#9670;&nbsp;</a></span>prvTCPSendCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t prvTCPSendCheck </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxDataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a>: some checks which will be done before sending a TCP packed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxDataLength</td><td>The length of the data to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: representing OK, else a negative error code will be returned. </dd></dl>

</div>
</div>
<a id="a91064db1bf7a4b1f49922c8f9927c701" name="a91064db1bf7a4b1f49922c8f9927c701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91064db1bf7a4b1f49922c8f9927c701">&#9670;&nbsp;</a></span>prvTCPSetSocketCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvTCPSetSocketCount </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t const *&#160;</td>
          <td class="paramname"><em>pxSocketToDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a child socket gets closed, make sure to update the child-count of the parent. When a listening parent socket is closed, make sure to close also all orphaned child-sockets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocketToDelete</td><td>The socket being closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d910cb9c6b4f63d7f8a75cd1ed7fa62" name="a5d910cb9c6b4f63d7f8a75cd1ed7fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d910cb9c6b4f63d7f8a75cd1ed7fa62">&#9670;&nbsp;</a></span>prvTCPConnectStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPConnectStart </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr const *&#160;</td>
          <td class="paramname"><em>pxAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called from <a class="el" href="_free_r_t_o_s___sockets_8c.html#a6231fb49e0a656c63d0ef82db2446587" title="Connect to a remote port.">FreeRTOS_connect()</a>: make some checks and if allowed, send a message to the IP-task to start connecting to a remote socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket attempting to connect to a remote port. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAddress</td><td>The address the socket is trying to connect to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful checks or a negative error code. </dd></dl>

</div>
</div>
<a id="ae8a5f1c37d0260304e2acb616ca18247" name="ae8a5f1c37d0260304e2acb616ca18247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a5f1c37d0260304e2acb616ca18247">&#9670;&nbsp;</a></span>bMayConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t bMayConnect </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t const *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if it makes any sense to wait for a connect event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket trying to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>It may return: -EINPROGRESS, -EAGAIN, or 0 for OK. </dd></dl>

</div>
</div>
<a id="a69915c323634b32c5534bd1a17b79673" name="a69915c323634b32c5534bd1a17b79673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69915c323634b32c5534bd1a17b79673">&#9670;&nbsp;</a></span>prvFindSelectedSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvFindSelectedSocket </td>
          <td>(</td>
          <td class="paramtype">SocketSelect_t *&#160;</td>
          <td class="paramname"><em>pxSocketSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to the IP-task to have it check all sockets belonging to 'pxSocketSet'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocketSet</td><td>The socket set being asked to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0707f288bef6f9a6cafd3dc3c4cfab99" name="a0707f288bef6f9a6cafd3dc3c4cfab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0707f288bef6f9a6cafd3dc3c4cfab99">&#9670;&nbsp;</a></span>FreeRTOS_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket_t FreeRTOS_socket </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate and initialise a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xDomain</td><td>The domain in which the socket should be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xType</td><td>The type of the socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xProtocol</td><td>The protocol of the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FREERTOS_INVALID_SOCKET if the allocation failed, or if there was a parameter error, otherwise a valid socket. </dd></dl>

</div>
</div>
<a id="a6ffb7662be38da18db6ec8e87da4735e" name="a6ffb7662be38da18db6ec8e87da4735e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb7662be38da18db6ec8e87da4735e">&#9670;&nbsp;</a></span>FreeRTOS_CreateSocketSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SocketSet_t FreeRTOS_CreateSocketSet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket set. </p>
<dl class="section return"><dt>Returns</dt><dd>The new socket set which was created, or NULL when allocation has failed. </dd></dl>

</div>
</div>
<a id="a427e342cb8d9c513d117ba772f427cca" name="a427e342cb8d9c513d117ba772f427cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427e342cb8d9c513d117ba772f427cca">&#9670;&nbsp;</a></span>FreeRTOS_DeleteSocketSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_DeleteSocketSet </td>
          <td>(</td>
          <td class="paramtype">SocketSet_t&#160;</td>
          <td class="paramname"><em>xSocketSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a given socket set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocketSet</td><td>The socket set being deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accf33877d948d53b4b189ddc41718ccd" name="accf33877d948d53b4b189ddc41718ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf33877d948d53b4b189ddc41718ccd">&#9670;&nbsp;</a></span>FreeRTOS_FD_SET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_FD_SET </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SocketSet_t&#160;</td>
          <td class="paramname"><em>xSocketSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventBits_t&#160;</td>
          <td class="paramname"><em>xBitsToSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a socket to a set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket being added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocketSet</td><td>The socket set being added to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBitsToSet</td><td>The event bits to set, a combination of the values defined in 'eSelectEvent_t', for read, write, exception, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecd213d4d45a6dbc0e900f52f2b4541" name="a7ecd213d4d45a6dbc0e900f52f2b4541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecd213d4d45a6dbc0e900f52f2b4541">&#9670;&nbsp;</a></span>FreeRTOS_FD_CLR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_FD_CLR </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SocketSet_t&#160;</td>
          <td class="paramname"><em>xSocketSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventBits_t&#160;</td>
          <td class="paramname"><em>xBitsToClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear select bits for a socket. If the mask becomes 0, remove the socket from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket whose select bits are being cleared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocketSet</td><td>The socket set of the socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBitsToClear</td><td>The bits to be cleared. Every '1' means that the corresponding bit will be cleared. See 'eSelectEvent_t' for the possible values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f05335fc45cca27dd28f122bb0f68bc" name="a8f05335fc45cca27dd28f122bb0f68bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05335fc45cca27dd28f122bb0f68bc">&#9670;&nbsp;</a></span>FreeRTOS_FD_ISSET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventBits_t FreeRTOS_FD_ISSET </td>
          <td>(</td>
          <td class="paramtype">const ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstSocketSet_t&#160;</td>
          <td class="paramname"><em>xSocketSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a socket belongs to a socket-set and if so, which event bit(s) are set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocketSet</td><td>The socket set to which the socket belongs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the socket belongs to the socket set: the event bits, otherwise zero. </dd></dl>

</div>
</div>
<a id="a659a570c1f1b5a11c17d816cb5541291" name="a659a570c1f1b5a11c17d816cb5541291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659a570c1f1b5a11c17d816cb5541291">&#9670;&nbsp;</a></span>FreeRTOS_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_select </td>
          <td>(</td>
          <td class="paramtype">SocketSet_t&#160;</td>
          <td class="paramname"><em>xSocketSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>xBlockTimeTicks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The select() statement: wait for an event to occur on any of the sockets included in a socket set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocketSet</td><td>The socket set including the sockets on which we are waiting for an event to occur. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBlockTimeTicks</td><td>Maximum time ticks to wait for an event to occur. If the value is 'portMAX_DELAY' then the function will wait indefinitely for an event to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket which might have triggered the event bit. </dd></dl>

</div>
</div>
<a id="a63957c5dde05f3a130cf7190aa935e25" name="a63957c5dde05f3a130cf7190aa935e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63957c5dde05f3a130cf7190aa935e25">&#9670;&nbsp;</a></span>FreeRTOS_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_recvfrom </td>
          <td>(</td>
          <td class="paramtype">const ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxSourceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const socklen_t *&#160;</td>
          <td class="paramname"><em>pxSourceAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from a bound socket. In this library, the function can only be used with connection-less sockets (UDP). For TCP sockets, please use <a class="el" href="_free_r_t_o_s___sockets_8c.html#a44ab7ba5fddce925519c7ccc7b887033" title="Read incoming data from a TCP socket. Only after the last byte has been read, a close error might be ...">FreeRTOS_recv()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket to which the data is sent i.e. the listening socket. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer in which the data being received is to be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>The length of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFlags</td><td>The flags to indicate preferences while calling this function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxSourceAddress</td><td>The source address from which the data is being sent. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxSourceAddressLength</td><td>This parameter is used only to adhere to Berkeley sockets standard. It is not used internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received. Or else, an error code is returned. When it returns a negative value, the cause can be looked-up in 'FreeRTOS_errno_TCP.h'. </dd></dl>

</div>
</div>
<a id="a3c30950fb7db5b68e0c4dcbbf838049b" name="a3c30950fb7db5b68e0c4dcbbf838049b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c30950fb7db5b68e0c4dcbbf838049b">&#9670;&nbsp;</a></span>prvMakeSureSocketIsBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvMakeSureSocketIsBound </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a socket is a valid UDP socket. In case it is not yet bound, bind it to port 0 ( random port ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket that must be bound to a port number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns pdTRUE if the socket was already bound, or if the socket has been bound successfully. </dd></dl>

</div>
</div>
<a id="a1493cacf34d993b8b87c41242d7fc6d1" name="a1493cacf34d993b8b87c41242d7fc6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493cacf34d993b8b87c41242d7fc6d1">&#9670;&nbsp;</a></span>FreeRTOS_sendto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_sendto </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxTotalDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxDestinationAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>xDestinationAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to a socket. The socket must have already been created by a successful call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a0707f288bef6f9a6cafd3dc3c4cfab99" title="allocate and initialise a socket.">FreeRTOS_socket()</a>. It works for UDP-sockets only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket being sent to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>Pointer to the data being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTotalDataLength</td><td>Length (in bytes) of the data being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFlags</td><td>Flags used to communicate preferences to the function. Possibly FREERTOS_MSG_DONTWAIT and/or FREERTOS_ZERO_COPY. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDestinationAddress</td><td>The address to which the data is to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDestinationAddressLength</td><td>This parameter is present to adhere to the Berkeley sockets standard. Else, it is not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When positive: the total number of bytes sent, when negative an error has occurred: it can be looked-up in 'FreeRTOS_errno_TCP.h'. </dd></dl>

</div>
</div>
<a id="a6fe933805d4f44b09b3b04a13ed28e72" name="a6fe933805d4f44b09b3b04a13ed28e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe933805d4f44b09b3b04a13ed28e72">&#9670;&nbsp;</a></span>FreeRTOS_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_bind </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr const *&#160;</td>
          <td class="paramname"><em>pxAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>xAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>binds a socket to a local port number. If port 0 is provided, a system provided port number will be assigned. This function can be used for both UDP and TCP sockets. The actual binding will be performed by the IP-task to avoid mutual access to the bound-socket-lists (xBoundUDPSocketsList or xBoundTCPSocketsList). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket being bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAddress</td><td>The address struct carrying the port number to which this socket is to be bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xAddressLength</td><td>This parameter is not used internally. The function signature is used to adhere to standard Berkeley sockets API.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is 0 if the bind is successful. If some error occurred, then a negative value is returned. </dd></dl>

</div>
</div>
<a id="add35977107add8357366416d55c64e69" name="add35977107add8357366416d55c64e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add35977107add8357366416d55c64e69">&#9670;&nbsp;</a></span>vSocketBind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t vSocketBind </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxBindAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxAddressLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xInternal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal version of bind() that should not be called directly. 'xInternal' is used for TCP sockets only: it allows to have several (connected) child sockets bound to the same server port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket is to be bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxBindAddress</td><td>The port to which this socket should be bound. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxAddressLength</td><td>The address length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInternal</td><td>pdTRUE is calling internally, else pdFALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the socket was bound to a port successfully, then a 0 is returned. Or else, an error code is returned. </dd></dl>

</div>
</div>
<a id="abefb0186bf6e06816a6acd12432dae9b" name="abefb0186bf6e06816a6acd12432dae9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefb0186bf6e06816a6acd12432dae9b">&#9670;&nbsp;</a></span>FreeRTOS_closesocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_closesocket </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a socket and free the allocated space. In case of a TCP socket: the connection will not be closed automatically. Subsequent messages for the closed socket will be responded to with a RST. The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>the socket being closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are three distinct values which can be returned: 0: If the xSocket is NULL/invalid. 1: If the socket was successfully closed (read the brief above). -1: If the socket was valid but could not be closed because the message could not be delivered to the IP-task. Try again later. </dd></dl>

</div>
</div>
<a id="afef498fc07f15ceb8828c60decabfbb8" name="afef498fc07f15ceb8828c60decabfbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef498fc07f15ceb8828c60decabfbb8">&#9670;&nbsp;</a></span>vSocketClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vSocketClose </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the internal version of <a class="el" href="_free_r_t_o_s___sockets_8c.html#abefb0186bf6e06816a6acd12432dae9b" title="Close a socket and free the allocated space. In case of a TCP socket: the connection will not be clos...">FreeRTOS_closesocket()</a>. It will be called by the IPtask only to avoid problems with synchronicity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket descriptor of the socket being closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL, always. </dd></dl>

</div>
</div>
<a id="a7faeae52e5489bc7b5ee8ab9392630d5" name="a7faeae52e5489bc7b5ee8ab9392630d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faeae52e5489bc7b5ee8ab9392630d5">&#9670;&nbsp;</a></span>FreeRTOS_setsockopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_setsockopt </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lOptionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvOptionValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxOptionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the socket options for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket for which the options are to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lLevel</td><td>Not used. Parameter is used to maintain the Berkeley sockets standard. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lOptionName</td><td>The name of the option to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvOptionValue</td><td>The value of the option to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionLength</td><td>Not used. Parameter is used to maintain the Berkeley sockets standard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the option can be set with the given value, then 0 is returned. Else, an error code is returned. </dd></dl>

</div>
</div>
<a id="ac3bf0f1817a52cf72307092b6e5cdcbf" name="ac3bf0f1817a52cf72307092b6e5cdcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bf0f1817a52cf72307092b6e5cdcbf">&#9670;&nbsp;</a></span>pxUDPSocketLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS_Socket_t * pxUDPSocketLookup </td>
          <td>(</td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxLocalPort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the UDP socket corresponding to the port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uxLocalPort</td><td>The port whose corresponding bound UDP socket is to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket owning the port if found or else NULL. </dd></dl>

</div>
</div>
<a id="a9fa2ddd54f04e8314a9b357527c53f56" name="a9fa2ddd54f04e8314a9b357527c53f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa2ddd54f04e8314a9b357527c53f56">&#9670;&nbsp;</a></span>FreeRTOS_inet_ntoa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * FreeRTOS_inet_ntoa </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the 32-bit representation of the IP-address to the dotted decimal notation after some checks. A safe alternative is <a class="el" href="_free_r_t_o_s___sockets_8c.html#a2a1d585f75b8fc47161cab0113b38174" title="Convert the 32-bit representation of the IP-address to the dotted decimal format.">FreeRTOS_inet_ntop4()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>32-bit representation of the IP-address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcBuffer</td><td>The buffer where the dotted decimal representation will be stored if all checks pass. The buffer must be at least 16 bytes long.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer returned will be same as pcBuffer and will have the address stored in the location. </dd></dl>

</div>
</div>
<a id="a47ae572a3caf62d61b5aaeb462914516" name="a47ae572a3caf62d61b5aaeb462914516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae572a3caf62d61b5aaeb462914516">&#9670;&nbsp;</a></span>FreeRTOS_inet_pton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_inet_pton </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xAddressFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the dotted decimal format of the IP-address to the 32-bit representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xAddressFamily</td><td>The Address family to which the IP-address belongs to. Only FREERTOS_AF_INET (IPv4) is supported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSource</td><td>Pointer to the string holding the dotted decimal representation of the IP-address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvDestination</td><td>The pointer to the address struct/variable where the converted IP-address will be stored. The buffer must be 4 bytes long in case of a IPv4 address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If all checks pass, then pdPASS is returned or else pdFAIL is returned. </dd></dl>

</div>
</div>
<a id="aac0f93b995b905805c8dc17bbd97ce04" name="aac0f93b995b905805c8dc17bbd97ce04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0f93b995b905805c8dc17bbd97ce04">&#9670;&nbsp;</a></span>FreeRTOS_inet_ntop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * FreeRTOS_inet_ntop </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xAddressFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>uxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the 32-bit representation of the IP-address to the dotted decimal format based on the Address Family. (Only FREERTOS_AF_INET is allowed). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xAddressFamily</td><td>The address family of the IP-address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSource</td><td>Pointer to the 32-bit representation of IP-address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcDestination</td><td>The pointer to the character array where the dotted decimal address will be stored if every check does pass. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxSize</td><td>Size of the character array. This value makes sure that the code doesn't write beyond it's bounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If every check does pass, then the pointer to the pcDestination is returned holding the dotted decimal format of IP-address. Else, a NULL is returned. </dd></dl>

</div>
</div>
<a id="a2a1d585f75b8fc47161cab0113b38174" name="a2a1d585f75b8fc47161cab0113b38174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1d585f75b8fc47161cab0113b38174">&#9670;&nbsp;</a></span>FreeRTOS_inet_ntop4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * FreeRTOS_inet_ntop4 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>uxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the 32-bit representation of the IP-address to the dotted decimal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSource</td><td>The pointer to the 32-bit representation of the IP-address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcDestination</td><td>The pointer to a character array where the string of the dotted decimal IP format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxSize</td><td>Size of the character array. This value makes sure that the code doesn't write beyond it's bounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the string holding the dotted decimal format of the IP-address. If everything passes correctly, then the pointer being returned is the same as pcDestination, else a NULL is returned. </dd></dl>

</div>
</div>
<a id="a078ca5deaf06141eb65d09ba28c6b8ac" name="a078ca5deaf06141eb65d09ba28c6b8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078ca5deaf06141eb65d09ba28c6b8ac">&#9670;&nbsp;</a></span>FreeRTOS_EUI48_ntop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_EUI48_ntop </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cTen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>cSeparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a 48-bit MAC address to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucSource</td><td>A pointer to an array of 6 bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcTarget</td><td>A buffer that is 18 bytes long, it will contain the resulting string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cTen</td><td>Either an 'A' or an 'a'. It determines whether the hex numbers will use capital or small letters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cSeparator</td><td>The separator that should appear between the bytes, either ':' or '-'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4741626233348eae3ac3d7d9c7de73fb" name="a4741626233348eae3ac3d7d9c7de73fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4741626233348eae3ac3d7d9c7de73fb">&#9670;&nbsp;</a></span>FreeRTOS_EUI48_pton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_EUI48_pton </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucTarget</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a human readable string, representing an 48-bit MAC address, into a 6-byte address. Valid inputs are e.g. "62:48:5:83:A0:b2" and "0-12-34-fe-dc-ba". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSource</td><td>The null terminated string to be parsed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucTarget</td><td>A buffer that is 6 bytes long, it will contain the MAC address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE in case the string got parsed correctly, otherwise pdFALSE. </dd></dl>

</div>
</div>
<a id="ae3306e04e9b856682503e39f856ec7ff" name="ae3306e04e9b856682503e39f856ec7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3306e04e9b856682503e39f856ec7ff">&#9670;&nbsp;</a></span>FreeRTOS_inet_pton4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_inet_pton4 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvDestination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts the character string pcSource into a network address structure, then copies the network address structure to pvDestination. pvDestination is written in network byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcSource</td><td>The character string in holding the IP address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvDestination</td><td>The returned network address in 32-bit network-endian format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS if the translation was successful or else pdFAIL. </dd></dl>

</div>
</div>
<a id="a17f785c94c2b8d0c80cf615a898c70b8" name="a17f785c94c2b8d0c80cf615a898c70b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f785c94c2b8d0c80cf615a898c70b8">&#9670;&nbsp;</a></span>FreeRTOS_inet_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_inet_addr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the IP address from "w.x.y.z" (dotted decimal) format to the 32-bit format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcIPAddress</td><td>The character string pointer holding the IP-address in the "W.X.Y.Z" (dotted decimal) format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit representation of IP(v4) address. </dd></dl>

</div>
</div>
<a id="a5cfd261a29fa206a8664ab5171ad9570" name="a5cfd261a29fa206a8664ab5171ad9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd261a29fa206a8664ab5171ad9570">&#9670;&nbsp;</a></span>FreeRTOS_GetLocalAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS_GetLocalAddress </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the local address and IP port of the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>Socket whose port is to be added to the pxAddress. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxAddress</td><td>Structure in which the IP address and the port number is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the freertos_sockaddr structure. </dd></dl>

</div>
</div>
<a id="a0387edebc3e7bcf7fcf038a01a098213" name="a0387edebc3e7bcf7fcf038a01a098213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0387edebc3e7bcf7fcf038a01a098213">&#9670;&nbsp;</a></span>vSocketWakeUpUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vSocketWakeUpUser </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake up the user of the given socket through event-groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose user is to be woken up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6231fb49e0a656c63d0ef82db2446587" name="a6231fb49e0a656c63d0ef82db2446587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6231fb49e0a656c63d0ef82db2446587">&#9670;&nbsp;</a></span>FreeRTOS_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_connect </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xClientSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>xAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xClientSocket</td><td>The socket initiating the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAddress</td><td>The address of the remote socket. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xAddressLength</td><td>This parameter is not used. It is kept in the function signature to adhere to the Berkeley sockets standard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on a successful connection, else a negative error code is returned. </dd></dl>

</div>
</div>
<a id="a1b0aabc4d95b9a61e531429839f50852" name="a1b0aabc4d95b9a61e531429839f50852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0aabc4d95b9a61e531429839f50852">&#9670;&nbsp;</a></span>FreeRTOS_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket_t FreeRTOS_accept </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xServerSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>pxAddressLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a connection on an listening socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xServerSocket</td><td>The socket in listening mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxAddress</td><td>The address of the machine trying to connect to this node is returned in this pointer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxAddressLength</td><td>The length of the address of the remote machine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FreeRTOS_accept: can return a new connected socket if the server socket is in listen mode and receives a connection request. The new socket will be bound already to the same port number as the listening socket. </dd></dl>

</div>
</div>
<a id="a44ab7ba5fddce925519c7ccc7b887033" name="a44ab7ba5fddce925519c7ccc7b887033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ab7ba5fddce925519c7ccc7b887033">&#9670;&nbsp;</a></span>FreeRTOS_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_recv </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read incoming data from a TCP socket. Only after the last byte has been read, a close error might be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvBuffer</td><td>The buffer to store the incoming data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>The length of the buffer so that the function does not do out of bound access. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFlags</td><td>The flags for conveying preference. The values FREERTOS_MSG_DONTWAIT, FREERTOS_ZERO_COPY and/or FREERTOS_MSG_PEEK can be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually received and stored in the pvBuffer. </dd></dl>

</div>
</div>
<a id="a68d0d5b9bbaa6c1a30a8fb5675fb151f" name="a68d0d5b9bbaa6c1a30a8fb5675fb151f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d0d5b9bbaa6c1a30a8fb5675fb151f">&#9670;&nbsp;</a></span>FreeRTOS_get_tx_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * FreeRTOS_get_tx_head </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t *&#160;</td>
          <td class="paramname"><em>pxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a direct pointer to the circular transmit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket owning the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxLength</td><td>This will contain the number of bytes that may be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Head of the circular transmit buffer if all checks pass. Or else, NULL is returned. </dd></dl>

</div>
</div>
<a id="abfb04a35d27c55380be674ebd8204351" name="abfb04a35d27c55380be674ebd8204351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb04a35d27c55380be674ebd8204351">&#9670;&nbsp;</a></span>FreeRTOS_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_send </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data using a TCP socket. It is not necessary to have the socket connected already. Outgoing data will be stored and delivered as soon as the socket gets connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The buffer containing the data. The value of this pointer may be NULL in case zero-copy transmissions are used. It is used in combination with '<a class="el" href="_free_r_t_o_s___sockets_8c.html#a68d0d5b9bbaa6c1a30a8fb5675fb151f" title="Get a direct pointer to the circular transmit buffer.">FreeRTOS_get_tx_head()</a>'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxDataLength</td><td>The length of the data to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFlags</td><td>This parameter is not used. (zero or FREERTOS_MSG_DONTWAIT).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent. Zero when nothing could be sent or a negative error code in case an error occurred. </dd></dl>

</div>
</div>
<a id="a1718a2539e0de40d95472ea59859be5c" name="a1718a2539e0de40d95472ea59859be5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1718a2539e0de40d95472ea59859be5c">&#9670;&nbsp;</a></span>FreeRTOS_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_listen </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xBacklog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to put a socket in listen mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>the socket to be put in listening mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xBacklog</td><td>Maximum number of child sockets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, or else a negative error code is returned. </dd></dl>

</div>
</div>
<a id="af3c0198b40cbd5c5e4bb4f173df4fff1" name="af3c0198b40cbd5c5e4bb4f173df4fff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c0198b40cbd5c5e4bb4f173df4fff1">&#9670;&nbsp;</a></span>FreeRTOS_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_shutdown </td>
          <td>(</td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xHow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown - This function will shut down the connection in both directions. However, it will first deliver all data queued for transmission, and also it will first wait to receive any missing packets from the peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xHow</td><td>Not used. Just present to stick to Berkeley standard.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful shutdown or else a negative error code. </dd></dl>

</div>
</div>
<a id="ad3802e1a3603f571bcb185f2afbd48de" name="ad3802e1a3603f571bcb185f2afbd48de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3802e1a3603f571bcb185f2afbd48de">&#9670;&nbsp;</a></span>xTCPTimerCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t xTCPTimerCheck </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xWillSleep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A TCP timer has expired, now check all TCP sockets for: </p>
<ul>
<li>Active connect</li>
<li>Send a delayed ACK</li>
<li>Send new data</li>
<li>Send a keep-alive packet</li>
<li>Check for timeout (in non-connected states only)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xWillSleep</td><td>Whether the calling task is going to sleep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum amount of time before the timer shall expire. </dd></dl>

</div>
</div>
<a id="a1b5c6d5f1fce62700029acd28e5857a1" name="a1b5c6d5f1fce62700029acd28e5857a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5c6d5f1fce62700029acd28e5857a1">&#9670;&nbsp;</a></span>pxTCPSocketLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS_Socket_t * pxTCPSocketLookup </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulLocalIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxLocalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulRemoteIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxRemotePort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As multiple sockets may be bound to the same local port number looking up a socket is a little more complex: Both a local port, and a remote port and IP address are being used to find a match. For a socket in listening mode, the remote port and IP address are both 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulLocalIP</td><td>Local IP address. Ignored for now. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxLocalPort</td><td>Local port number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulRemoteIP</td><td>Remote (peer) IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxRemotePort</td><td>Remote (peer) port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket which was found. </dd></dl>

</div>
</div>
<a id="a289ae5cbba5316a7d0b8b5054cb68cdd" name="a289ae5cbba5316a7d0b8b5054cb68cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289ae5cbba5316a7d0b8b5054cb68cdd">&#9670;&nbsp;</a></span>FreeRTOS_get_rx_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structstruct.html">struct</a> xSTREAM_BUFFER * FreeRTOS_get_rx_buf </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the web server: borrow the circular Rx buffer for inspection. HTML driver wants to see if a sequence of 13/10/13/10 is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket whose Rx stream is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Rx stream of the socket if all checks pass, else NULL. </dd></dl>

</div>
</div>
<a id="a712ce92b8518f62444aad31e0fb1d424" name="a712ce92b8518f62444aad31e0fb1d424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ce92b8518f62444aad31e0fb1d424">&#9670;&nbsp;</a></span>lTCPAddRxdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t lTCPAddRxdata </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to the RxStream. When uxOffset &gt; 0, data has come in out-of-order and will be put in front of the head so it can not be popped by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to whose RxStream data is to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOffset</td><td>Offset of the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcData</td><td>The data to be added to the RxStream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulByteCount</td><td>Number of bytes in the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually added to the RxStream. Or else, a negative error code is returned. </dd></dl>

</div>
</div>
<a id="a9e0d7303574cd99128cbdb79e54adc89" name="a9e0d7303574cd99128cbdb79e54adc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0d7303574cd99128cbdb79e54adc89">&#9670;&nbsp;</a></span>FreeRTOS_GetRemoteAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_GetRemoteAddress </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the remote IP-address and port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>Socket owning the connection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxAddress</td><td>The address pointer to which the address is to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the address being returned. Or else a negative error code will be returned. </dd></dl>

</div>
</div>
<a id="a50d7c4b5b3eeea34905a4f16b6f13965" name="a50d7c4b5b3eeea34905a4f16b6f13965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d7c4b5b3eeea34905a4f16b6f13965">&#9670;&nbsp;</a></span>FreeRTOS_maywrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_maywrite </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the number of bytes that may be added to txStream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes that may be added to txStream or else a negative error code. </dd></dl>

</div>
</div>
<a id="ab49ef118747de118579ce9ba6e2d3d10" name="ab49ef118747de118579ce9ba6e2d3d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49ef118747de118579ce9ba6e2d3d10">&#9670;&nbsp;</a></span>FreeRTOS_tx_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_tx_space </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes that can be written in the Tx buffer of the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>the socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bytes that can be written. Or else an error code. </dd></dl>

</div>
</div>
<a id="af92a73b86b115ac2caeaf6d98d696723" name="af92a73b86b115ac2caeaf6d98d696723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a73b86b115ac2caeaf6d98d696723">&#9670;&nbsp;</a></span>FreeRTOS_tx_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_tx_size </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes stored in the Tx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes stored in the Tx buffer of the socket. Or an error code. </dd></dl>

</div>
</div>
<a id="ad8dffb3417a60b9c98108408052579ad" name="ad8dffb3417a60b9c98108408052579ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dffb3417a60b9c98108408052579ad">&#9670;&nbsp;</a></span>FreeRTOS_issocketconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_issocketconnected </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the socket connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket being checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if TCP socket is connected. </dd></dl>

</div>
</div>
<a id="a10a19083f6bdd12aa4e0a8e508454385" name="a10a19083f6bdd12aa4e0a8e508454385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a19083f6bdd12aa4e0a8e508454385">&#9670;&nbsp;</a></span>FreeRTOS_mss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_mss </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual value of Maximum Segment Size ( MSS ) being used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket whose MSS is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual size of MSS being used or an error code. </dd></dl>

</div>
</div>
<a id="a0a6df495a5df34259dd6ef400992a46f" name="a0a6df495a5df34259dd6ef400992a46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6df495a5df34259dd6ef400992a46f">&#9670;&nbsp;</a></span>FreeRTOS_connstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_connstatus </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the connection status. The values correspond to the members of the enum 'eIPTCPState_t'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>Socket to get the connection status from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The connection status or an error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For internal use only. </dd></dl>

</div>
</div>
<a id="a6780a9d34f029526febb9b8a26f1b0c5" name="a6780a9d34f029526febb9b8a26f1b0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6780a9d34f029526febb9b8a26f1b0c5">&#9670;&nbsp;</a></span>FreeRTOS_rx_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_rx_size </td>
          <td>(</td>
          <td class="paramtype">ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes which can be read from the RX stream buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>the socket to get the number of bytes from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes which can be read. Or an error code is returned. </dd></dl>

</div>
</div>
<a id="ac7d3b9e3f9a2a974cd8382c8755e603f" name="ac7d3b9e3f9a2a974cd8382c8755e603f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d3b9e3f9a2a974cd8382c8755e603f">&#9670;&nbsp;</a></span>xSocketValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xSocketValid </td>
          <td>(</td>
          <td class="paramtype">const ConstSocket_t&#160;</td>
          <td class="paramname"><em>xSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given socket is valid or not. Validity is defined as the socket not being NULL and not being Invalid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSocket</td><td>The socket to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the socket is valid, else pdFALSE. </dd></dl>

</div>
</div>
<a id="a4e52838681336e8b2dcd41298072c764" name="a4e52838681336e8b2dcd41298072c764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e52838681336e8b2dcd41298072c764">&#9670;&nbsp;</a></span>vSocketSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vSocketSelect </td>
          <td>(</td>
          <td class="paramtype">const SocketSelect_t *&#160;</td>
          <td class="paramname"><em>pxSocketSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This internal non-blocking function will check all sockets that belong to a select set. The events bits of each socket will be updated, and it will check if an ongoing select() call must be interrupted because of an event has occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocketSet</td><td>The socket-set which is to be waited on for change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___sockets_8c.html">FreeRTOS_Sockets.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
